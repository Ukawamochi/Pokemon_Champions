#!/usr/bin/env node
"use strict";

const fs = require("fs");
const path = require("path");

require("ts-node").register({
  transpileOnly: true,
  compilerOptions: {
    module: "CommonJS",
    moduleResolution: "Node",
    esModuleInterop: true,
    target: "ES2019",
  },
});

const SHOWDOWN_DATA = path.resolve(__dirname, "../pokemon-showdown/data");
const OUTPUT_DIR = path.resolve(process.argv[2] || path.resolve(__dirname, "../src/data"));

const { Pokedex } = require(path.resolve(SHOWDOWN_DATA, "pokedex"));
const { Moves } = require(path.resolve(SHOWDOWN_DATA, "moves"));
const { Abilities } = require(path.resolve(SHOWDOWN_DATA, "abilities"));
const { Items } = require(path.resolve(SHOWDOWN_DATA, "items"));
const { TypeChart } = require(path.resolve(SHOWDOWN_DATA, "typechart"));

function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

function toRustString(value) {
  if (value === undefined || value === null) {
    return "";
  }
  return value
    .toString()
    .replace(/\\/g, "\\\\")
    .replace(/"/g, '\\"');
}

function fmtFloat(value) {
  if (value === undefined || value === null || Number.isNaN(value)) {
    return "0.0";
  }
  if (Number.isInteger(value)) {
    return `${value}.0`;
  }
  return value.toString();
}

function renderSpecies(pokedex) {
  const entries = Object.entries(pokedex).sort((a, b) => {
    const aNum = a[1].num ?? 0;
    const bNum = b[1].num ?? 0;
    if (aNum !== bNum) {
      return aNum - bNum;
    }
    return a[0].localeCompare(b[0]);
  });
  const lines = [];
  lines.push("// AUTO-GENERATED by tools/extract_data.js");
  lines.push("use phf::phf_map;");
  lines.push("");
  lines.push("#[derive(Clone, Copy, Debug)]");
  lines.push("pub struct BaseStats {");
  lines.push("    pub hp: u8,");
  lines.push("    pub atk: u8,");
  lines.push("    pub def: u8,");
  lines.push("    pub spa: u8,");
  lines.push("    pub spd: u8,");
  lines.push("    pub spe: u8,");
  lines.push("}");
  lines.push("");
  lines.push("#[derive(Clone, Copy, Debug)]");
  lines.push("pub struct AbilitySlots {");
  lines.push("    pub primary: Option<&'static str>,");
  lines.push("    pub secondary: Option<&'static str>,");
  lines.push("    pub hidden: Option<&'static str>,");
  lines.push("}");
  lines.push("");
  lines.push("#[derive(Clone, Copy, Debug)]");
  lines.push("pub struct SpeciesData {");
  lines.push("    pub num: i16,");
  lines.push("    pub name: &'static str,");
  lines.push("    pub base_stats: BaseStats,");
  lines.push("    pub types: [&'static str; 2],");
  lines.push("    pub abilities: AbilitySlots,");
  lines.push("    pub weight_kg: f32,");
  lines.push("}");
  lines.push("");
  lines.push("pub static POKEDEX: phf::Map<&'static str, SpeciesData> = phf_map! {");
  for (const [id, entry] of entries) {
    const key = id;
    const baseStats = entry.baseStats || {};
    const types = entry.types || [];
    const type1 = types[0] || "";
    const type2 = types[1] || "";
    const abilities = entry.abilities || {};
    const primary = abilities["0"] || "";
    const secondary = abilities["1"] || null;
    const hidden = abilities["H"] || null;
    const weight = entry.weightkg ?? 0;
    lines.push(
      `    "${key}" => SpeciesData {`,
      `        num: ${entry.num ?? 0},`,
      `        name: "${toRustString(entry.name ?? key)}",`,
      `        base_stats: BaseStats {`,
      `            hp: ${baseStats.hp ?? 0},`,
      `            atk: ${baseStats.atk ?? 0},`,
      `            def: ${baseStats.def ?? 0},`,
      `            spa: ${baseStats.spa ?? 0},`,
      `            spd: ${baseStats.spd ?? 0},`,
      `            spe: ${baseStats.spe ?? 0},`,
      `        },`,
      `        types: ["${toRustString(type1)}", "${toRustString(type2)}"],`,
      `        abilities: AbilitySlots {`,
      `            primary: ${primary ? `Some("${toRustString(primary)}")` : "None"},`,
      `            secondary: ${secondary ? `Some("${toRustString(secondary)}")` : "None"},`,
      `            hidden: ${hidden ? `Some("${toRustString(hidden)}")` : "None"},`,
      `        },`,
      `        weight_kg: ${fmtFloat(weight)},`,
      `    },`
    );
  }
  lines.push("};");
  return lines.join("\n");
}

function renderMoves(moves) {
  const entries = Object.entries(moves).sort((a, b) => {
    const aNum = a[1].num ?? 0;
    const bNum = b[1].num ?? 0;
    if (aNum !== bNum) {
      return aNum - bNum;
    }
    return a[0].localeCompare(b[0]);
  });
  const lines = [];
  lines.push("// AUTO-GENERATED by tools/extract_data.js");
  lines.push("use phf::phf_map;");
  lines.push("");
  lines.push("#[derive(Clone, Copy, Debug)]");
  lines.push("pub enum MoveCategory {");
  lines.push("    Physical,");
  lines.push("    Special,");
  lines.push("    Status,");
  lines.push("}");
  lines.push("");
  lines.push("#[derive(Clone, Copy, Debug)]");
  lines.push("pub struct SecondaryEffect {");
  lines.push("    pub chance: u8,");
  lines.push("    pub status: Option<&'static str>,");
  lines.push("    pub volatile_status: Option<&'static str>,");
  lines.push("    pub boosts: &'static [(&'static str, i8)],");
  lines.push("    pub side_condition: Option<&'static str>,");
  lines.push("    pub weather: Option<&'static str>,");
  lines.push("    pub terrain: Option<&'static str>,");
  lines.push("}");
  lines.push("");
  lines.push("#[derive(Clone, Copy, Debug)]");
  lines.push("pub struct MoveData {");
  lines.push("    pub num: i16,");
  lines.push("    pub name: &'static str,");
  lines.push("    pub move_type: &'static str,");
  lines.push("    pub category: MoveCategory,");
  lines.push("    pub base_power: Option<u16>,");
  lines.push("    pub accuracy: Option<f32>,");
  lines.push("    pub pp: Option<u8>,");
  lines.push("    pub priority: i8,");
  lines.push("    pub target: &'static str,");
  lines.push("    pub flags: &'static [&'static str],");
  lines.push("    pub secondary: Option<SecondaryEffect>,");
  lines.push("    pub secondaries: &'static [SecondaryEffect],");
  lines.push("    pub self_effect: Option<SecondaryEffect>,");
  lines.push("    pub crit_ratio: Option<u8>,");
  lines.push("    pub recoil: Option<(u8, u8)>,");
  lines.push("    pub drain: Option<(u8, u8)>,");
  lines.push("    pub multihit: Option<(u8, u8)>,");
  lines.push("}");
  lines.push("");
  lines.push("pub static MOVES: phf::Map<&'static str, MoveData> = phf_map! {");

  function renderSecondaryEffect(effect, chanceValue) {
    const status = effect && effect.status ? effect.status : null;
    const volatileStatus = effect && effect.volatileStatus ? effect.volatileStatus : null;
    const boosts = effect && effect.boosts ? effect.boosts : null;
    const sideCondition = effect && effect.sideCondition ? effect.sideCondition : null;
    const weather = effect && effect.weather ? effect.weather : null;
    const terrain = effect && effect.terrain ? effect.terrain : null;

    const boostsEntries = boosts
      ? Object.entries(boosts).sort((a, b) => a[0].localeCompare(b[0]))
      : [];

    const lines = [];
    lines.push("SecondaryEffect {");
    lines.push(`            chance: ${Math.round(chanceValue)},`);
    lines.push(`            status: ${status ? `Some(\"${toRustString(status)}\")` : "None"},`);
    lines.push(
      `            volatile_status: ${
        volatileStatus ? `Some(\"${toRustString(volatileStatus)}\")` : "None"
      },`
    );
    if (boostsEntries.length === 0) {
      lines.push("            boosts: &[],");
    } else {
      lines.push(
        `            boosts: &[${boostsEntries
          .map(([stat, amount]) => `(\"${toRustString(stat)}\", ${Number(amount)})`)
          .join(", ")}],`
      );
    }
    lines.push(
      `            side_condition: ${
        sideCondition ? `Some(\"${toRustString(sideCondition)}\")` : "None"
      },`
    );
    lines.push(
      `            weather: ${weather ? `Some(\"${toRustString(weather)}\")` : "None"},`
    );
    lines.push(
      `            terrain: ${terrain ? `Some(\"${toRustString(terrain)}\")` : "None"},`
    );
    lines.push("        }");
    return lines;
  }

  for (const [id, entry] of entries) {
    const rawCategory = (entry.category || "Status").toString();
    const category =
      rawCategory.charAt(0).toUpperCase() + rawCategory.slice(1).toLowerCase();
    const moveType = entry.type || "Normal";
    const basePower = entry.basePower;
    const accuracyRaw = entry.accuracy;
    const accuracy =
      accuracyRaw === true ? 100.0 : accuracyRaw === false ? 0.0 : accuracyRaw;
    const pp = entry.pp;
    const priority = entry.priority ?? 0;
    const target = entry.target || "normal";
    const flags = Object.keys(entry.flags || {}).sort();
    const secondary = entry.secondary;
    const secondaryChance =
      secondary && typeof secondary.chance === "number" ? secondary.chance : secondary ? 100 : null;
    const secondaries = Array.isArray(entry.secondaries) ? entry.secondaries : [];
    const selfEffect = entry.self || null;
    const selfChance =
      selfEffect && typeof selfEffect.chance === "number" ? selfEffect.chance : selfEffect ? 100 : null;
    const crit = entry.critRatio;
    const recoil = Array.isArray(entry.recoil)
      ? entry.recoil
      : entry.recoil && entry.recoil[0] && entry.recoil[1]
      ? entry.recoil
      : null;
    const drain = Array.isArray(entry.drain)
      ? entry.drain
      : entry.drain && entry.drain[0] && entry.drain[1]
      ? entry.drain
      : null;
    const multihitObj = entry.multihit || entry.multiHit;
    let multihit = null;
    if (Array.isArray(multihitObj) && multihitObj.length >= 2) {
      multihit = [multihitObj[0], multihitObj[1]];
    } else if (multihitObj && typeof multihitObj === "object") {
      multihit = [
        multihitObj.minHits ?? multihitObj.min ?? 1,
        multihitObj.maxHits ?? multihitObj.max ?? multihitObj.minHits ?? 1,
      ];
    }
    lines.push(`    "${id}" => MoveData {`);
    lines.push(`        num: ${entry.num ?? 0},`);
    lines.push(`        name: "${toRustString(entry.name || id)}",`);
    lines.push(`        move_type: "${toRustString(moveType)}",`);
    lines.push(`        category: MoveCategory::${category},`);
    lines.push(
      `        base_power: ${basePower === undefined ? "None" : `Some(${basePower})`},`
    );
    if (accuracy === undefined || accuracy === null) {
      lines.push("        accuracy: None,");
    } else {
      lines.push(`        accuracy: Some(${fmtFloat(accuracy)}),`);
    }
    lines.push(
      `        pp: ${pp === undefined ? "None" : `Some(${pp})`},`
    );
    lines.push(`        priority: ${priority},`);
    lines.push(`        target: "${toRustString(target)}",`);
    if (flags.length === 0) {
      lines.push("        flags: &[],");
    } else {
      lines.push(
        `        flags: &[${
          flags.map((f) => `"${toRustString(f)}"`).join(", ")
        }],`
      );
    }
    if (secondaryChance === null) {
      lines.push("        secondary: None,");
    } else {
      lines.push("        secondary: Some(");
      lines.push(...renderSecondaryEffect(secondary, secondaryChance).map((l) => "        " + l));
      lines.push("        ),");
    }
    if (secondaries.length === 0) {
      lines.push("        secondaries: &[],");
    } else {
      lines.push("        secondaries: &[");
      for (const sec of secondaries) {
        const chance =
          sec && typeof sec.chance === "number" ? sec.chance : sec ? 100 : 0;
        const rendered = renderSecondaryEffect(sec, chance);
        for (let i = 0; i < rendered.length; i++) {
          const line = i === rendered.length - 1 ? rendered[i] + "," : rendered[i];
          lines.push("            " + line);
        }
      }
      lines.push("        ],");
    }
    if (selfChance === null) {
      lines.push("        self_effect: None,");
    } else {
      lines.push("        self_effect: Some(");
      lines.push(...renderSecondaryEffect(selfEffect, selfChance).map((l) => "        " + l));
      lines.push("        ),");
    }
    lines.push(`        crit_ratio: ${crit === undefined ? "None" : `Some(${crit})`},`);
    if (recoil && recoil.length >= 2) {
      lines.push(`        recoil: Some((${recoil[0]}, ${recoil[1]})),`);
    } else {
      lines.push("        recoil: None,");
    }
    if (drain && drain.length >= 2) {
      lines.push(`        drain: Some((${drain[0]}, ${drain[1]})),`);
    } else {
      lines.push("        drain: None,");
    }
    if (multihit && multihit.length >= 2) {
      lines.push(`        multihit: Some((${multihit[0]}, ${multihit[1]})),`);
    } else {
      lines.push("        multihit: None,");
    }
    lines.push("    },");
  }
  lines.push("};");
  lines.push("");
  lines.push("pub fn normalize_move_name(name: &str) -> String {");
  lines.push(
    "    name.to_ascii_lowercase().chars().filter(|c| c.is_ascii_alphanumeric()).collect()"
  );
  lines.push("}");
  lines.push("");
  lines.push("pub fn get_move(name_or_id: &str) -> Option<&'static MoveData> {");
  lines.push("    let id = normalize_move_name(name_or_id);");
  lines.push("    MOVES.get(id.as_str())");
  lines.push("}");
  return lines.join("\n");
}

function renderAbilities(abilities) {
  const entries = Object.entries(abilities).sort((a, b) => {
    const aNum = a[1].num ?? 0;
    const bNum = b[1].num ?? 0;
    if (aNum !== bNum) {
      return aNum - bNum;
    }
    return a[0].localeCompare(b[0]);
  });
  const lines = [];
  lines.push("// AUTO-GENERATED by tools/extract_data.js");
  lines.push("use phf::phf_map;");
  lines.push("");
  lines.push("#[derive(Clone, Copy, Debug)]");
  lines.push("pub struct AbilityData {");
  lines.push("    pub num: i16,");
  lines.push("    pub name: &'static str,");
  lines.push("    pub description: &'static str,");
  lines.push("}");
  lines.push("");
  lines.push("pub static ABILITIES: phf::Map<&'static str, AbilityData> = phf_map! {");
  for (const [id, entry] of entries) {
    const description = entry.desc || entry.shortDesc || "";
    lines.push(`    "${id}" => AbilityData {`);
    lines.push(`        num: ${entry.num ?? 0},`);
    lines.push(`        name: "${toRustString(entry.name || id)}",`);
    lines.push(`        description: "${toRustString(description)}",`);
    lines.push("    },");
  }
  lines.push("};");
  return lines.join("\n");
}

function renderItems(items) {
  const entries = Object.entries(items).sort((a, b) => {
    const aNum = a[1].num ?? 0;
    const bNum = b[1].num ?? 0;
    if (aNum !== bNum) {
      return aNum - bNum;
    }
    return a[0].localeCompare(b[0]);
  });
  const lines = [];
  lines.push("// AUTO-GENERATED by tools/extract_data.js");
  lines.push("use phf::phf_map;");
  lines.push("");
  lines.push("#[derive(Clone, Copy, Debug)]");
  lines.push("pub struct ItemData {");
  lines.push("    pub num: i16,");
  lines.push("    pub name: &'static str,");
  lines.push("    pub description: &'static str,");
  lines.push("}");
  lines.push("");
  lines.push("pub static ITEMS: phf::Map<&'static str, ItemData> = phf_map! {");
  for (const [id, entry] of entries) {
    const description = entry.desc || entry.shortDesc || "";
    lines.push(`    "${id}" => ItemData {`);
    lines.push(`        num: ${entry.num ?? 0},`);
    lines.push(`        name: "${toRustString(entry.name || id)}",`);
    lines.push(`        description: "${toRustString(description)}",`);
    lines.push("    },");
  }
  lines.push("};");
  return lines.join("\n");
}

function renderTypes(typeChart) {
  const typeOrder = [
    "normal",
    "fire",
    "water",
    "electric",
    "grass",
    "ice",
    "fighting",
    "poison",
    "ground",
    "flying",
    "psychic",
    "bug",
    "rock",
    "ghost",
    "dragon",
    "dark",
    "steel",
    "fairy",
  ];
  const orderIndex = {};
  typeOrder.forEach((name, idx) => {
    orderIndex[name.toLowerCase()] = idx;
  });

  const matrix = Array.from({ length: typeOrder.length }, () =>
    Array(typeOrder.length).fill(1.0)
  );

  for (const [defType, data] of Object.entries(typeChart)) {
    const defIndex = orderIndex[defType.toLowerCase()];
    if (defIndex === undefined) {
      continue;
    }
    const damageTaken = data.damageTaken || {};
    for (const [attType, value] of Object.entries(damageTaken)) {
      const attIndex = orderIndex[attType.toLowerCase()];
      if (attIndex === undefined) {
        continue;
      }
      let multiplier = 1.0;
      if (value === 1) {
        multiplier = 2.0;
      } else if (value === 2) {
        multiplier = 0.5;
      } else if (value === 3) {
        multiplier = 0.0;
      }
      matrix[attIndex][defIndex] = multiplier;
    }
  }

  const lines = [];
  lines.push("// AUTO-GENERATED by tools/extract_data.js");
  lines.push("#[derive(Clone, Copy, Debug, Eq, PartialEq)]");
  lines.push("pub enum Type {");
  typeOrder.forEach((typeName) => {
    const variant = typeName
      .split(/[^a-zA-Z]/)
      .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
      .join("");
    lines.push(`    ${variant},`);
  });
  lines.push("}");
  lines.push("");
  lines.push("impl Type {");
  lines.push("    pub fn as_index(&self) -> usize {");
  lines.push("        *self as usize");
  lines.push("    }");
  lines.push("}");
  lines.push("");
  lines.push("pub fn effectiveness_against(attacking: Type, defending: Type) -> f32 {");
  lines.push("    EFFECTIVENESS[attacking.as_index()][defending.as_index()]");
  lines.push("}");
  lines.push("");
  lines.push(
    "pub fn effectiveness_dual(attacking: Type, type1: Type, type2: Type) -> f32 {"
  );
  lines.push(
    "    effectiveness_against(attacking, type1) * effectiveness_against(attacking, type2)"
  );
  lines.push("}");
  lines.push("");
  lines.push("const EFFECTIVENESS: [[f32; 18]; 18] = [");
  matrix.forEach((row) => {
    const values = row.map((value) => fmtFloat(value));
    lines.push(`    [${values.join(", ")}],`);
  });
  lines.push("];");
  return lines.join("\n");
}

function writeFile(name, content) {
  const filePath = path.join(OUTPUT_DIR, `${name}.rs`);
  fs.writeFileSync(filePath, content + "\n");
}

function main() {
  ensureDir(OUTPUT_DIR);
  writeFile("species", renderSpecies(Pokedex));
  writeFile("moves", renderMoves(Moves));
  writeFile("abilities", renderAbilities(Abilities));
  writeFile("items", renderItems(Items));
  writeFile("types", renderTypes(TypeChart));
}

main();
